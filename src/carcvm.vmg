\ Copyright (C) 2009 Rafael R. Sevilla
\
\ This file is part of CArc
\
\ CArc is free software; you can redistribute it and/or modify it
\ under the terms of the GNU Lesser General Public License as
\ published by the Free Software Foundation; either version 3 of the
\ License, or (at your option) any later version.
\
\ This library is distributed in the hope that it will be useful,
\ but WITHOUT ANY WARRANTY; without even the implied warranty of
\ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\ GNU Lesser General Public License for more details.
\
\ You should have received a copy of the GNU Lesser General Public
\ License along with this library; if not, write to the Free Software
\ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA
\ 02110-1301 USA.

\E stack data-stack sp value

\E inst-stream stack-prefix #

\E s" value"   single data-stack type-prefix i

\E s" Inst *"  single data-stack type-prefix target

\ No operation
nop ( -- )

\ Push a value in the value register into the stack
push ( -- i )
i = TVALR(thr);

\ Pop the stack, and place its topmost value into the value reg.
pop ( i -- )
TVALR(thr) = i;

\ The ldl instruction loads a literal value from the literal values
\ in the funr register into value register.
ldl ( #i -- )
TVALR(thr) = CODE_LITERAL(TFUNR(thr), i);

\ Load an immediate value (usually a fixnum) into the value register
ldi ( #i -- )
TVALR(thr) = i;

\ Load a global value.  The value in the instruction is generally a
\ symbol, and indexes into the global symbol table.
ldg ( #i -- )
{
  value tmp;

  tmp = CODE_LITERAL(TFUNR(thr), i);
  if ((TVALR(thr) = carc_hash_lookup(c, c->genv, tmp)) == CUNBOUND) {
    c->signal_error(c, "Unbound symbol %S\n", tmp);
    TVALR(thr) = CNIL;
  }
}

\ Set a global value with the value of the value register
stg ( #i -- )
carc_hash_insert(c, c->genv, CODE_LITERAL(TFUNR(thr), i), TVALR(thr));

\ Load the value of a variable in the environment.  The first
\ operand is the number of the environment, and the second is
\ the index into that environment.
lde ( #ienv #iindx -- )
{
  value tmp = TENVR(thr);
  while (--ienv >= 0) tmp = cdr(tmp);
  TVALR(thr) = ENV_VALUE(car(tmp), iindx);
}

\ Store to an environment variable
ste ( #ienv #iindx -- )
{
  value tmp = TENVR(thr);
  while (--ienv >= 0) tmp = cdr(tmp);
  WB(&ENV_VALUE(car(tmp), iindx), TVALR(thr));
}

\ Make a continuation at offset icofs, placing it in the value register.
cont ( #icofs -- )
WB(&TCONR(thr), cons(c, carc_mkcont(c, INT2FIX(icofs), thr), TCONR(thr)));

\ Make an environment of a given size, with names from the function register
env ( #ienvsize -- )
WB(&TENVR(thr), carc_mkenv(c, TENVR(thr), ienvsize));
ENV_NAMES(TENVR(thr)) = CODE_NAME(TFUNR(thr));
WB(&VINDEX(car(TENVR(thr)), 0), VINDEX(TFUNR(thr), 2));

\ apply a function
apply ( #iargc -- )
TARGC(thr) = iargc;
carc_apply(c, thr, TVALR(thr));
SET_IP(TIP(thr));


ret ( -- )
carc_return(c, thr);
SET_IP(TIP(thr));

\ Jump unconditional
jmp ( #target -- )
SET_IP(target);

\ Jump if valr is not nil
jt ( #target -- )
if (TVALR(thr) != CNIL) {
  SET_IP(target);
  INST_TAIL;
}

\ Jump if valr is nil
jf ( #target -- )
if (TVALR(thr) == CNIL) {
  SET_IP(target);
  INST_TAIL;
}

true ( -- )
TVALR(thr) = CTRUE;

nil ( -- )
TVALR(thr) = CNIL;

\ Halt execution of this virtual machine thread
hlt ( -- )
TSTATE(thr) = Trelease;
goto endquantum;

\ Maybe we can do without the instructions below this point, and
\ make everything a function call, however that would probably be
\ very slow until we can figure out how to do inline caching
\ properly.
add  ( i -- )
TVALR(thr) = __carc_add2(c, TVALR(thr), i);

sub ( i -- )
TVALR(thr) = __carc_sub2(c, TVALR(thr), i);

mul ( i -- )
TVALR(thr) = __carc_mul2(c, TVALR(thr), i);

div ( i -- )
TVALR(thr) = __carc_div2(c, TVALR(thr), i);

cons ( i -- )
TVALR(thr) = cons(c, TVALR(thr), i);

car ( -- )
TVALR(thr) = car(TVALR(thr));

cdr ( -- )
TVALR(thr) = cdr(TVALR(thr));

scar ( inc -- )
scar(TVALR(thr), inc);

scdr ( inc -- )
scdr(TVALR(thr), inc);

is ( i -- )
TVALR(thr) = carc_is(c, TVALR(thr), i);

\ XXX - right now this only works for numeric args.
cmp ( i -- )
TVALR(thr) = carc_numcmp(c, TVALR(thr), i);
