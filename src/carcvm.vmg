\ Copyright (C) 2009 Rafael R. Sevilla
\
\ This file is part of CArc
\
\ CArc is free software; you can redistribute it and/or modify it
\ under the terms of the GNU Lesser General Public License as
\ published by the Free Software Foundation; either version 3 of the
\ License, or (at your option) any later version.
\
\ This library is distributed in the hope that it will be useful,
\ but WITHOUT ANY WARRANTY; without even the implied warranty of
\ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
\ GNU Lesser General Public License for more details.
\
\ You should have received a copy of the GNU Lesser General Public
\ License along with this library; if not, write to the Free Software
\ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston MA
\ 02110-1301 USA.

\E stack data-stack sp value

\E inst-stream stack-prefix #

\E s" value"   single data-stack type-prefix i

\E s" Inst *"  single data-stack type-prefix target

nop ( -- )

drop ( i -- )

dup ( i -- i1 i2 )
i1 = i2 = i;

\ The ldl instruction loads a literal value from the literal values
\ in the funr register into the stack.  The instruction argument
\ is its index into the funr vector and should in most cases be 3 or
\ higher for properly compiled code.
ldl ( #i2 -- i )
i = VINDEX(t->funr, i2);

\ Load an immediate value (usually a fixnum)
ldi ( #i2 -- i )
i = i2;

\ Load a global value.  The value in the instruction is generally a
\ symbol, and indexes into the global symbol table.
ldg ( #i2 -- i )
{
  value tmp;

  tmp = VINDEX(t->funr, i2);
  if ((i = carc_hash_lookup(c, c->genv, tmp)) == CUNBOUND) {
    c->signal_error(c, "Unbound symbol %S\n", tmp);
    i = CNIL;
  }
}

\ Set a global value
stg ( #i2 i -- )
carc_hash_insert(c, c->genv, VINDEX(t->funr, i2), i);

\ Load the value of a variable in the environment.  The first
\ operand is the number of the environment, and the second is
\ the index into that environment.
lde ( #ienv #iindx -- ival)
{
  value tmp = t->envr;
  while (--ienv >= 0) tmp = cdr(tmp);
  ival = VINDEX(car(tmp), iindx);
}

\ Store to an environment variable
ste ( #ienv #iindx -- ival)
{
  value tmp = t->envr;
  while (--ienv >= 0) tmp = cdr(tmp);
  WB(&VINDEX(car(tmp), iindx), ival);
}

\ Make a continuation
cont ( #icofs -- icont)
icont = carc_mkcont(c, INT2FIX(icofs), t->funr, t->envr);

\ Make an environment of a given size
env ( #ienvsize -- )
WB(&t->envr, carc_mkenv(c, t->envr, ienvsize));
WB(&VINDEX(car(t->envr), 0), VINDEX(t->funr, 2));

\ Move an argument from the stack into the given slot number
\ in the environment
mvarg ( #islot -- i )
if (--(t->argc) < 0)
  c->signal_error(c, "too few arguments in call to %S", VINDEX(t->funr, 1));
WB(&VINDEX(car(t->envr), islot), i);

\ Jump unconditional
jmp ( #i -- )
INC_IP(i);

\ Jump if top of stack is not nil
jt ( #i icond -- )
if (icond != CNIL) {
  INC_IP(i);
  NEXT_P0;
}

\ Jump if top of stack is nil
jf ( #i icond -- )
if (icond == CNIL) {
  INC_IP(i);
  NEXT_P0;
}

true ( -- i )
i = CTRUE;

nil ( -- i )
i = CNIL;

\ Halt execution of this virtual machine thread
hlt ( -- )
t->state = Trelease;
goto endquantum;

\ Maybe we can do without the instructions below this point, and
\ make everything a function call, however that would probably be
\ very slow until we can figure out how to do inline caching
\ properly.
add ( i1 i2 -- i )
i = __carc_add2(c, i1, i2);

sub ( i1 i2 -- i )
i = __carc_sub2(c, i1, i2);

mul ( i1 i2 -- i )
i = __carc_mul2(c, i1, i2);

div ( i1 i2 -- i )
i = __carc_div2(c, i1, i2);

cons ( i1 i2 -- i )
i = cons(c, i1, i2);

car ( i -- ic )
ic = car(i);

cdr (i -- ic )
ic = cdr(i);

is ( i1 i2 -- i )
i = carc_is(c, i1, i2);

