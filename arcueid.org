ARCUEID ROADMAP
Copyright (C) 2010,2011 Rafael R. Sevilla
----------------------------------------------------------------------
Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.
----------------------------------------------------------------------

* The Arc Runtime
   We want to be able to write as little of the runtime in C as
   possible.  Of course, unless we have an Arc to native compiler, or
   even a limited one analogous to Richard Kelsey's PreScheme, we have
   no choice but to write a few portions in C.  I don't yet have the
   chops or the time to make one like that now, but that would
   certainly be ideal, and then we'd have an Arc just like Scheme48.
** DONE base virtual machine [7/7]
   We need to rethink the structure of the virtual machine.  It now
   seems that vmgen might not have been such a good idea, and we
   should probably write our own interpreter core directly.
    - [X] Define virtual machine architecture
    - [X] Design interpreter core
	  The interpreter core should be flexible enough that we can
	  easily use switch threading, call threading, GCC labels as
	  values, or even assembly language.  Each instruction should
	  be separately implementable.
    - [X] Build code generation infrastructure
    - [X] Implement virtual machine instructions [39/39]
      - [X] nop
      - [X] push
      - [X] pop
      - [X] ldl
      - [X] ldi
      - [X] ldg
      - [X] stg
      - [X] lde
      - [X] ste
      - [X] mvarg
      - [X] mvoarg
      - [X] mvrarg
      - [X] cont
      - [X] env
      - [X] apply
      - [X] ret
      - [X] jmp
      - [X] jt
      - [X] jf
      - [X] true
      - [X] nil
      - [X] hlt
      - [X] add
      - [X] sub
      - [X] mul
      - [X] div
      - [X] cons
      - [X] car
      - [X] cdr
      - [X] scar
      - [X] scdr
      - [X] spl
      - [X] is
      - [X] iso
      - [X] gt
      - [X] lt
      - [X] dup
      - [X] cls
      - [X] consr
    - [X] Build a foreign function interface [4/4]
      - [X] Calling convention 1 (straight args)
      - [X] Calling convention 2 (args as a C array)
      - [X] Calling convention 3 (args as an Arcueid vector)
      - [X] Calling convention 4 - functions that can call Arc functions
    - [X] Enable GCC's labels as values for doing interpreter threading
	  The macro structure is already in place.  We only need to fill
	  in some of the conditional compilation stuff and defines.
    - [X] Type invocations [5/5]
	 We need to modify the arc_apply function so that it becomes
	 possible to apply objects of these various types
      - [X] procedure
      - [X] list
      - [X] vector
      - [X] table
      - [X] string
** DONE memory management [2/2]
   - [X] memory allocator
	 A very simple free-list based memory allocator.  There might be
	 better algorithms out there but let's get a simple one out
	 the door first and then worry about making it more efficient
	 later.
   - [X] garbage collector
	 We use the Huelsbergen-Winterbottom VCGC algorithm.  We use
	 it single-threaded exactly the way Inferno uses it, with
	 interpretation interleaved with garbage collection.  Later on
	 when we have real threads in the language we'll make it into
	 a real threaded implementation with a real OS-level thread to
	 do the marking and sweeping.
** DONE compiler in Arc
    Debugging and feature-completeness are all on the agenda of course.
** TODO basic data types [11/14]
    - [X] Nil
    - [X] True
    - [X] Numeric Types [5/5]
       - [X] fixnum
       - [X] bignum
       - [X] flonum
       - [X] complex
       - [X] rational
    - [X] Characters
    - [X] Strings
    - [X] Symbols
    - [X] Conses
    - [X] Tables
    - [X] Vectors
    - [ ] Tagged
    - [ ] Functions
    - [X] Input Ports
    - [X] Output Ports
    - [ ] Threads
** TODO Runtime Built-In Functions [8/17]
   Consider whether or not to provide instructions for the asterisked
   functions, so as to make their use cheaper.
   - [X] Initialization for binding runtime primitives to global symbols
   - [X] Type handling [5/5]
     - [X] coerce [10/10]
       - [X] Integer conversions [5/5]
	     Note that fixnum and bignum may be used as aliases for int
         - [X] char -> int (results in a fixnum from 0 - 0x10FFFF)
         - [X] flonum -> int
	       Either fixnum or bignum as needed.
         - [X] complex -> int
	       optional argument for imaginary, use 'im
         - [X] rational -> int
	       May return fixnum or bignum as needed
         - [X] string -> int, base specified as optional arg
       - [X] Flonum conversions [5/5]
         - [X] fixnum -> flonum
         - [X] bignum -> flonum
         - [X] rational -> flonum
         - [X] complex -> flonum
	       Extra argument for Im(z)
         - [X] string -> flonum
	       A base may be specified here as well.  Arc3 does not allow
	       specification of an exponent for bases greater than 14, but
	       Arcueid allows alternate use of an '&' character to denote
               exponents (after Simula), or a 'p/P' character for bases
               less than 25 (as per strtod).  The strings 'Â±inf' and 'nan'
               with any capitalization, with or without a trailing .0, will
               create an infinity or a NaN respectively.
       - [X] Rational conversions [5/5]
         - [X] fixnum -> rational
	       This has no real effect.  It will still return the original
	       fixnum, without error.         
         - [X] bignum -> rational
	       Also has no effect, returning the original bignum without
	       error.
         - [X] flonum -> rational
         - [X] complex -> rational
	       Extra argument for Im(z)
         - [X] string -> rational, base specified as optional arg
	       May return a fixnum or a bignum instead depending on the
	       value therein.
       - [X] Complex conversions [5/5]
         - [X] fixnum -> complex
	       Works the same as fixnum -> flonum
         - [X] bignum -> complex
	       Works the same as bignum -> flonum
         - [X] flonum -> complex
	       Has no effect, returning the original flonum
         - [X] string -> complex
	       May return a flonum if no imaginary part is specified.
	 - [X] cons -> complex
       - [X] String conversions [10/10]
	 - [X] nil -> string
         - [X] char -> string
         - [X] fixnum -> string
	       Has extra argument specifying base
         - [X] bignum -> string
	       Has extra argument specifying base
         - [X] rational -> string
	       Has extra argument specifying base
         - [X] flonum -> string
         - [X] complex -> string
         - [X] cons -> string
         - [X] vector -> string
         - [X] symbol -> string
       - [X] Cons conversions [4/4]
         - [X] rational -> cons
	       car = numerator, cdr = denominator, could be fixnums or
	       bignums as needed.
         - [X] complex -> cons
	       car = Re(z), cdr = Im(z)
         - [X] vector -> cons
         - [X] string -> cons (char list)
       - [X] Symbol conversions [2/2]
         - [X] char -> sym
         - [X] string -> sym
       - [X] Vector conversions [2/2]
         - [X] string -> vector (char vector)
         - [X] cons -> vector
       - [X] fixnum -> char
             limit to 0 - 0x10FFFF, also exclude 0xd800-0xdfff, invalid
	     Unicode block.
       - [X] string -> num
	     Converts any string into a number of the appropriate
	     type.  This should use the best available numeric type
	     that is able to most accurately represent the value
	     described by the string.  Numeric base may be specified
	     as an optional argument as before.

	     Basic algorithm makes the following tests:

	 1. If string ends with 'i' or 'j', convert as complex
	 2. If string contains '.', convert as floating point.
	 3. If base is less than 14 and the string contains 'e/E',
	    convert as floating point.
	 4. If base is less than 25 and the string contains 'p/P',
	    convert as floating point.
	 5. If string contains '&', convert as floating point.
	 6. If string contains '/', convert as rational.
	 7. Otherwise, consider string as representing an integer
     - [X] type
     - [X] annotate
     - [X] rep
     - [X] sym
   - [X] Predicates [9/9]
     - [X] Less-than (<) *
     - [X] Greater-than (>) *
     - [X] Less-than or equal (<=) *
     - [X] Greater-than or equal (>=) *
     - [X] spaceship operator (<=>) * (Arcueid extension)
     - [X] bound
     - [X] exact
     - [X] is
     - [X] iso
   - [X] List operations [5/5]
     - [X] car (implemented as a virtual machine instruction)
     - [X] cdr (implemented as a virtual machine instruction)
     - [X] cons (implemented as a virtual machine instruction)
     - [X] scar (implemented as a virtual machine instruction)
     - [X] scdr (implemented as a virtual machine instruction)
   - [-] Math operations [5/8]
     - [X] * Multiplication (virtual machine instruction)
     - [X] + Addition (virtual machine instruction)
     - [X] - Subtraction (virtual machine instruction)
     - [X] / Division (virtual machine instruction)
     - [X] idiv integer division
     - [-] Arc3-current functions [2/5]
       - [X] expt
       - [X] mod
       - [ ] rand
       - [ ] sqrt
       - [ ] trunc
     - [ ] Complex arithmetic [0/6]
	   This is again an Arcueid extension.  It's rather annoying
	   to have support for complex numbers but no functions to
	   manipulate them.
       - [ ] real
       - [ ] imag
       - [ ] sreal
       - [ ] simag
       - [ ] conjugate
       - [ ] arg -- complex argument
     - [-] C99 math.h functions (Arcueid only) [2/37]
	   These functions should support complex arguments in as far
	   as it makes sense to do so.
       - [X] abs -- works for all numeric types
       - [ ] acos
       - [ ] acosh
       - [ ] asin
       - [ ] asinh
       - [ ] atan
       - [ ] atan2
       - [ ] atanh
       - [ ] cbrt
       - [ ] ceil
       - [ ] cos
       - [ ] cosh
       - [ ] erf
       - [ ] erfc
       - [ ] exp
       - [ ] expm1
       - [ ] fmod
       - [ ] frexp
       - [ ] hypot
       - [ ] ldexp
       - [ ] lgamma
       - [ ] log
       - [ ] log10
       - [ ] log2
       - [ ] logb
       - [ ] modf
       - [ ] nan
       - [ ] nearbyint
       - [X] pow (alias for expt)
       - [ ] modf
       - [ ] sin
       - [ ] sinh
       - [ ] sqrt (also in arc3)
       - [ ] tan
       - [ ] tanh
       - [ ] tgamma
       - [ ] trunc (also in arc3)
   - [X] Table operations [2/2]
     - [X] maptable
     - [X] table
   - [-] Evaluation [1/4]
     - [ ] eval
     - [X] apply
     - [ ] ssexpand
     - [ ] ssyntax
   - [-] Macros [2/4]
     - [X] macex (implemented in Arc)
     - [X] macex1 (implemented in Arc)
     - [ ] sig
	   This is actually a global variable, and needs to be
	   assigned at initialization.	   
     - [ ] uniq
   - [X] Basic I/O primitives (src/io.c) [3/3]
         These are the base I/O functions provided by the Arcueid C
         runtime.
     - [X] Input [4/4]
       - [X] readb
       - [X] readc
       - [X] peekc
	     Implemented in terms of ungetc
       - [X] ungetc - this is not part of standard Arc
	   Note that there is no ungetb function.  This is proving a
	   little tricky to implement.  Maybe what we should do is
	   simplify the semantics of ungetc so that it requires a
	   character to be unget'd, and the next call to readc OR
	   readb (yes, readb with a 'b'!) will return this
	   CHARACTER.  This saves us the trouble of decoding Unicode
	   all over again, and reinforces the maxim of never mixing
	       the b functions with the c functions.
     - [X] Output [2/2]
       - [X] writeb
       - [X] writec
     - [X] File I/O [5/5]
       - [X] infile
       - [X] outfile
       - [X] close
       - [X] String port I/O [3/3]
	     Note that doing readb/writeb or readc/writec on a string
	     port have the same effect.  Strings are made up of Unicode
	     characters so it would be quite messy to implement a
	     separate 'byte index' into what is made up of characters.
	 - [X] instring
	 - [X] outstring
	 - [X] inside
       - [X] Seeking / telling [2/2]
             Note that these essential functions are not available in
             PG-Arc for some reason but will probably be necessary to
             implement CIEL.
         - [X] seek
         - [X] tell
   - [ ] Additional I/O functions (src/io.c) [0/3]
         These other I/O functions are defined in standard Arc but are not
         necessary for CIEL or the reader, so we do them later.
     - [ ] File I/O [0/1]
       - [ ] pipe-from
     - [ ] stdin, stdout, stderr [0/5]
       - [ ] stdin
       - [ ] stdout
       - [ ] stderr
       - [ ] call-w/stdin
       - [ ] call-w/stdout
     - [ ] Threads [0/3]
       - [ ] Creating and managing threads [0/3]
         - [ ] new-thread
         - [ ] break-thread
         - [ ] kill-thread
       - [ ] Synchronization (basic) [0/1]
	 - [ ] atomic-invoke
       - [ ] Channels (cf. Limbo and CSP) [0/4]
	 - [ ] chan
         - [ ] <-
         - [ ] ->
         - [ ] alt
   - [ ] Networking [0/10]
     - [ ] open-socket
     - [ ] open-socket-dgram (Arcueid only)
     - [ ] client-ip
     - [ ] socket-accept
     - [ ] socket-bind (Arcueid only)
     - [ ] socket-listen (Arcueid only)
     - [ ] socket-connect (Arcueid only)
     - [ ] socket-sendto (Arcueid only)
     - [ ] socket-recvfrom (Arcueid only)
     - [ ] select (Arcueid only)
	   This should use epoll(7) on Linux or similar functions
	   on systems that support them.  Only fall back to standard
	   POSIX.1-2001 select(2) only if no alternatives are
	   available.
   - [ ] File system operations [0/4]
     - [ ] dir
     - [ ] dir-exists
     - [ ] file-exists
     - [ ] rmfile
   - [ ] Threading [0/6]
     - [ ] atomic-invoke
     - [ ] break-thread
     - [ ] dead
     - [ ] kill-thread
     - [ ] new-thread (spawn)
     - [ ] sleep
   - [ ] Error handling and continuations [0/5]
     - [ ] details
     - [ ] err
     - [ ] on-err
     - [ ] ccc
     - [ ] protect
   - [X] Time [4/4]
     - [X] current-gc-milliseconds
     - [X] current-process-milliseconds
     - [X] msec
     - [X] seconds
   - [ ] Miscellaneous OS operations [0/2]
     - [ ] system
     - [ ] quit
   - [X] Miscellaneous [2/2]
     - [X] sref *
     - [X] len
** TODO write a base reader for CIEL files (src/ciel.c) [1/2]
   Our CIEL bytecode interpreter must at the very least support the
   instructions given in comp-bsdef.arc and be able to decode CIEL
   files generated therein.  This should produce code objects suitable
   for use by the interpreter.
   - [X] CIEL instructions [15/15]
     - [X] gnil
     - [X] gtrue
     - [X] gint
     - [X] gflo
     - [X] gchar
     - [X] gstr
     - [X] gsym
     - [X] gbstr - binary strings
     - [X] crat
     - [X] ccomplex
     - [X] ccons
     - [X] cannotate - this is for the moment limited to creating T_CODE
	   objects from a cons consisting of the binary bytecode string
	   and literals
     - [X] xdup
     - [X] xmst
     - [X] xmld
   - [ ] Test the base reader by loading more non-trivial code generated
	 by the compiler
** TODO rewrite reader in Arc

** TODO write pretty printer in Arc
** TODO Formatted output
   In addition to Arc standard prf, there will also be a printf
   function which can be used to output strings according to a format
   string specified.  The usual conversion specifiers for standard C
   printf are available, with some additional non-standard ones:
   - r or m : no argument required - print the output of
     strerror(errno).
   - v : replace by the pretty-printed form of the argument.

   This is also the same format specification used by the error
   handler function signal_error.

** TODO Additional CIEL instructions [0/3]
   The following additional instructions are required by the final version:
   - [ ] gtab
   - [ ] ctadd
   - [ ] additional functionality for cannotate, so that it can, you
	 know, actually perform type annotations...
* Enhancements
** TODO use ropes as strings
   This is a valuable enhancement as efficent string handling for very
   long strings will be very useful.
** TODO true OS-level threading
   The current interpreter is designed with green threads, scheduled
   by the virtual machine rather than native threads.
** TODO more advanced memory allocator
** TODO just in time compilation
** TODO PreArc?
   We do want to someday make a statically-typed, non-garbage
   collected dialect of Arc similar to Richard Kelsey's PreScheme, so
   we can write the entire runtime in Arc.
** TODO Format strings
   We will provide for format strings similar to C, but with a few
   extensions that make sense for Arc.
