ARCUEID ROADMAP
Copyright (C) 2010,2011 Rafael R. Sevilla
----------------------------------------------------------------------
Copying and distribution of this file, with or without modification,
are permitted in any medium without royalty provided the copyright
notice and this notice are preserved.
----------------------------------------------------------------------

* The Arc Runtime
** DONE base virtual machine [7/7]
   We need to rethink the structure of the virtual machine.  It now
   seems that vmgen might not have been such a good idea, and we
   should probably write our own interpreter core directly.
    - [X] Define virtual machine architecture
    - [X] Design interpreter core
	  The interpreter core should be flexible enough that we can
	  easily use switch threading, call threading, GCC labels as
	  values, or even assembly language.  Each instruction should
	  be separately implementable.
    - [X] Build code generation infrastructure
    - [X] Implement virtual machine instructions [39/39]
      - [X] nop
      - [X] push
      - [X] pop
      - [X] ldl
      - [X] ldi
      - [X] ldg
      - [X] stg
      - [X] lde
      - [X] ste
      - [X] mvarg
      - [X] mvoarg
      - [X] mvrarg
      - [X] cont
      - [X] env
      - [X] apply
      - [X] ret
      - [X] jmp
      - [X] jt
      - [X] jf
      - [X] true
      - [X] nil
      - [X] hlt
      - [X] add
      - [X] sub
      - [X] mul
      - [X] div
      - [X] cons
      - [X] car
      - [X] cdr
      - [X] scar
      - [X] scdr
      - [X] spl
      - [X] is
      - [X] iso
      - [X] gt
      - [X] lt
      - [X] dup
      - [X] cls
      - [X] consr
    - [X] Build a foreign function interface [4/4]
      - [X] Calling convention 1 (straight args)
      - [X] Calling convention 2 (args as a C array)
      - [X] Calling convention 3 (args as an Arcueid vector)
      - [X] Calling convention 4 - functions that can call Arc functions
    - [X] Enable GCC's labels as values for doing interpreter threading
	  The macro structure is already in place.  We only need to fill
	  in some of the conditional compilation stuff and defines.
    - [X] Type invocations [5/5]
	 We need to modify the arc_apply function so that it becomes
	 possible to apply objects of these various types
      - [X] procedure
      - [X] list
      - [X] vector
      - [X] table
      - [X] string
** DONE memory management [2/2]
   - [X] memory allocator
	 A very simple free-list based memory allocator.  There might be
	 better algorithms out there but let's get a simple one out
	 the door first and then worry about making it more efficient
	 later.
   - [X] garbage collector
	 We use the Huelsbergen-Winterbottom VCGC algorithm.  We use
	 it single-threaded exactly the way Inferno uses it, with
	 interpretation interleaved with garbage collection.  Later on
	 when we have real threads in the language we'll make it into
	 a real threaded implementation with a real OS-level thread to
	 do the marking and sweeping.
** DONE Arc reader [11/11]
   - [X] Lists
   - [X] Improper lists
   - [X] Bracketed functions
   - [X] Quotes
   - [X] Quasiquotes
   - [X] Comma expressions
   - [X] Strings
   - [X] Characters
   - [X] Comments
   - [X] Atoms and Symbols
   - [X] Special syntax
** DONE Arc compiler [4/4]
   - [X] Literal expressions [9/9]
     - [X] nil
     - [X] true (t)
     - [X] character
     - [X] string
     - [X] fixnum
     - [X] bignum
     - [X] flonum
     - [X] rational
     - [X] complex
   - [X] Symbols [2/2]
     - [X] Environment symbols
     - [X] Global symbols
   - [X] Lists [3/3]
     - [X] Special forms [5/5]
       - [X] if
       - [X] fn [5/5]
	 - [X] single symbol arguments
	 - [X] simple argument lists
	 - [X] optional arguments
         - [X] rest arguments
	 - [X] destructuring binds
       - [X] quote
       - [X] quasiquote
       - [X] assign
     - [X] Inline functions [10/10]
       - [X] cons
       - [X] car
       - [X] cdr
       - [X] scar
       - [X] scdr
       - [X] is
       - [X] +
       - [X] -
       - [X] *
       - [X] /
     - [X] Function applications
   - [X] Macros
** TODO basic data types [14/16]
    - [X] Nil
    - [X] True
    - [X] Numeric Types [5/5]
      - [X] fixnum
      - [X] bignum
      - [X] flonum
      - [X] complex
      - [X] rational
    - [X] Characters
    - [X] Strings
    - [X] Symbols
    - [X] Conses
    - [X] Tables
    - [X] Vectors
    - [X] Tagged
    - [X] Functions
    - [X] Input Ports
    - [X] Output Ports
    - [X] Threads
    - [ ] Channels
    - [ ] Regular Expressions
** TODO Runtime Built-In Functions [16/19]
   Consider whether or not to provide instructions for the asterisked
   functions, so as to make their use cheaper.
   - [X] Initialization for binding runtime primitives to global symbols
   - [X] Type handling [5/5]
     - [X] coerce [10/10]
       - [X] Integer conversions [5/5]
	     Note that fixnum and bignum may be used as aliases for int
         - [X] char -> int (results in a fixnum from 0 - 0x10FFFF)
         - [X] flonum -> int
	       Either fixnum or bignum as needed.
         - [X] complex -> int
	       optional argument for imaginary, use 'im
         - [X] rational -> int
	       May return fixnum or bignum as needed
         - [X] string -> int, base specified as optional arg
       - [X] Flonum conversions [5/5]
         - [X] fixnum -> flonum
         - [X] bignum -> flonum
         - [X] rational -> flonum
         - [X] complex -> flonum
	       Extra argument for Im(z)
         - [X] string -> flonum
	       A base may be specified here as well.  Arc3 does not allow
	       specification of an exponent for bases greater than 14, but
	       Arcueid allows alternate use of an '&' character to denote
               exponents (after Simula), or a 'p/P' character for bases
               less than 25 (as per strtod).  The strings 'Â±inf' and 'nan'
               with any capitalization, with or without a trailing .0, will
               create an infinity or a NaN respectively.
       - [X] Rational conversions [5/5]
         - [X] fixnum -> rational
	       This has no real effect.  It will still return the original
	       fixnum, without error.         
         - [X] bignum -> rational
	       Also has no effect, returning the original bignum without
	       error.
         - [X] flonum -> rational
         - [X] complex -> rational
	       Extra argument for Im(z)
         - [X] string -> rational, base specified as optional arg
	       May return a fixnum or a bignum instead depending on the
	       value therein.
       - [X] Complex conversions [5/5]
         - [X] fixnum -> complex
	       Works the same as fixnum -> flonum
         - [X] bignum -> complex
	       Works the same as bignum -> flonum
         - [X] flonum -> complex
	       Has no effect, returning the original flonum
         - [X] string -> complex
	       May return a flonum if no imaginary part is specified.
	 - [X] cons -> complex
       - [X] String conversions [10/10]
	 - [X] nil -> string
         - [X] char -> string
         - [X] fixnum -> string
	       Has extra argument specifying base
         - [X] bignum -> string
	       Has extra argument specifying base
         - [X] rational -> string
	       Has extra argument specifying base
         - [X] flonum -> string
         - [X] complex -> string
         - [X] cons -> string
         - [X] vector -> string
         - [X] symbol -> string
       - [X] Cons conversions [4/4]
         - [X] rational -> cons
	       car = numerator, cdr = denominator, could be fixnums or
	       bignums as needed.
         - [X] complex -> cons
	       car = Re(z), cdr = Im(z)
         - [X] vector -> cons
         - [X] string -> cons (char list)
       - [X] Symbol conversions [2/2]
         - [X] char -> sym
         - [X] string -> sym
       - [X] Vector conversions [2/2]
         - [X] string -> vector (char vector)
         - [X] cons -> vector
       - [X] fixnum -> char
             limit to 0 - 0x10FFFF, also exclude 0xd800-0xdfff, invalid
	     Unicode block.
       - [X] string -> num
	     Converts any string into a number of the appropriate
	     type.  This should use the best available numeric type
	     that is able to most accurately represent the value
	     described by the string.  Numeric base may be specified
	     as an optional argument as before.

	     Basic algorithm makes the following tests:

	 1. If string ends with 'i' or 'j', convert as complex
	 2. If string contains '.', convert as floating point.
	 3. If base is less than 14 and the string contains 'e/E',
	    convert as floating point.
	 4. If base is less than 25 and the string contains 'p/P',
	    convert as floating point.
	 5. If string contains '&', convert as floating point.
	 6. If string contains '/', convert as rational.
	 7. Otherwise, consider string as representing an integer
     - [X] type
     - [X] annotate
     - [X] rep
     - [X] sym
   - [X] Predicates [10/10]
     - [X] Less-than (<) *
     - [X] Greater-than (>) *
     - [X] Less-than or equal (<=) *
     - [X] Greater-than or equal (>=) *
     - [X] spaceship operator (<=>) * (Arcueid extension)
     - [X] bound
     - [X] exact
     - [X] is
     - [X] iso
     - [X] fixnump
   - [X] List operations [5/5]
     - [X] car (implemented as a virtual machine instruction)
     - [X] cdr (implemented as a virtual machine instruction)
     - [X] cons (implemented as a virtual machine instruction)
     - [X] scar (implemented as a virtual machine instruction)
     - [X] scdr (implemented as a virtual machine instruction)
   - [X] Math operations [4/4]
     - [X] Arithmetic [5/5]
       - [X] * Multiplication (virtual machine instruction)
       - [X] + Addition (virtual machine instruction)
       - [X] - Subtraction (virtual machine instruction)
       - [X] / Division (virtual machine instruction)
       - [X] idiv integer division
     - [X] Complex arithmetic [4/4]
	   This is again an Arcueid extension.  It's rather annoying
	   to have support for complex numbers but no functions to
	   manipulate them.
       - [X] real
       - [X] imag
       - [X] conj
       - [X] arg -- complex argument
     - [X] Arc3-current functions [6/6]
       - [X] expt
       - [X] mod
       - [X] rand
       - [X] srand
       - [X] sqrt
       - [X] trunc
     - [X] C99 math.h functions (Arcueid only) [37/37]
	   These functions should support complex arguments in as far
	   as it makes sense to do so.
       - [X] abs -- works for all numeric types
       - [X] acos
       - [X] acosh
       - [X] asin
       - [X] asinh
       - [X] atan
       - [X] atan2
       - [X] atanh
       - [X] cbrt
       - [X] ceil
       - [X] cos
       - [X] cosh
       - [X] erf
       - [X] erfc
       - [X] exp
       - [X] expm1
       - [X] floor
       - [X] fmod
       - [X] frexp
       - [X] hypot
       - [X] ldexp
       - [X] lgamma
       - [X] log
       - [X] log10
       - [X] log2
       - [X] logb
       - [X] modf
       - [X] nan
       - [X] nearbyint
       - [X] pow (alias for expt)
       - [X] sin
       - [X] sinh
       - [X] sqrt (also in arc3)
       - [X] tan
       - [X] tanh
       - [X] tgamma
       - [X] trunc (also in arc3)
   - [X] Table operations [2/2]
     - [X] maptable
     - [X] table
   - [X] Evaluation [4/4]
     - [X] eval
	   We will implement eval by calling the compiler on the
	   expression to be evaluated.  The output of the compiler
	   is a T_CODE object which we can convert into a closure by
	   combining it with the caller's environment.
     - [X] apply
     - [X] ssexpand
     - [X] ssyntax
   - [X] Macros [4/4]
     - [X] macex
     - [X] macex1
     - [X] sig
	   This is actually a global variable, and needs to be
	   assigned at initialization.	   
     - [X] uniq
   - [X] Basic I/O primitives (src/io.c) [5/5]
         These are the base I/O functions provided by the Arcueid C
         runtime.
     - [X] Input [5/5]
       - [X] readb
       - [X] readc
       - [X] peekc
	     Implemented in terms of ungetc
       - [X] ungetc - this is not part of standard Arc
	   Note that there is no ungetb function.  This is proving a
	   little tricky to implement.  Maybe what we should do is
	   simplify the semantics of ungetc so that it requires a
	   character to be unget'd, and the next call to readc OR
	   readb (yes, readb with a 'b'!) will return this
	   CHARACTER.  This saves us the trouble of decoding Unicode
	   all over again, and reinforces the maxim of never mixing
	   the b functions with the c functions.
       - [X] sread
     - [X] Output [3/3]
       - [X] writeb
       - [X] writec
       - [X] write
     - [X] File I/O [3/3]
       - [X] infile
       - [X] outfile
       - [X] close
     - [X] String port I/O [3/3]
	     Note that doing readb/writeb or readc/writec on a string
	     port have the same effect.  Strings are made up of Unicode
	     characters so it would be quite messy to implement a
	     separate 'byte index' into what is made up of characters.
       - [X] instring
       - [X] outstring
       - [X] inside
     - [X] Seeking / telling [2/2]
             Note that these essential functions are not available in
             PG-Arc for some reason but will probably be necessary to
             implement CIEL.
       - [X] seek
       - [X] tell
   - [X] Additional I/O functions (src/io.c) [7/7]
         These other I/O functions are defined in standard Arc but are not
         necessary for CIEL or the reader, so we do them later.
     - [X] pipe-from
     - [X] stdin
     - [X] stdout
     - [X] stderr
     - [X] call-w/stdin
     - [X] call-w/stdout
     - [X] disp
   - [-] Threads [1/2]
     - [-] Creating and managing threads [5/7]
       - [X] new-thread (spawn)
       - [ ] break-thread
       - [ ] kill-thread
       - [X] dead
       - [X] sleep
       - [X] atomic-invoke - implemented using channels
       - [X] tjoin (not in standard Arc)
     - [X] Channels (cf. Limbo and CSP, Arcueid extension) [3/3]
       - [X] chan
       - [X] <- (recv-channel) *
       - [X] <-= (send-channel) *
   - [ ] Networking [0/10]
     - [ ] open-socket
     - [ ] open-socket-dgram (Arcueid only)
     - [ ] client-ip
     - [ ] socket-accept
     - [ ] socket-bind (Arcueid only)
     - [ ] socket-listen (Arcueid only)
     - [ ] socket-connect (Arcueid only)
     - [ ] socket-sendto (Arcueid only)
     - [ ] socket-recvfrom (Arcueid only)
     - [ ] select (Arcueid only)
	   This should use epoll(7) on Linux or similar functions
	   on systems that support them.  Only fall back to standard
	   POSIX.1-2001 select(2) only if no alternatives are
	   available.
   - [X] File system operations [4/4]
     - [X] dir
     - [X] dir-exists
     - [X] file-exists
     - [X] rmfile
   - [X] Error handling and continuations [5/5]
     - [X] details
     - [X] err
     - [X] on-err
     - [X] ccc
     - [X] protect
   - [X] Strings [1/1]
     - [X] newstring
   - [X] Time [4/4]
     - [X] current-gc-milliseconds
     - [X] current-process-milliseconds
     - [X] msec
     - [X] seconds
   - [ ] Regular Expressions [0/3]
     - [ ] rxcompile
     - [ ] rxescape
     - [ ] rxmatch (=~)
   - [X] Miscellaneous OS operations [2/2]
     - [X] system
     - [X] quit
   - [X] Miscellaneous [3/3]
     - [X] sref *
     - [X] len
     - [X] bound
** TODO Threading [3/6]
   - [X] Basic scheduling
   - [X] Suspend threads on I/O
   - [X] Synchronization
   - [ ] Deadlock detection
   - [ ] Thread control
   - [ ] alt mechanism
** TODO Baseline environment (arc.arc)
   We will doubtless need to customize the base environment provided in
   PG-Arc.
** TODO pretty printer
** DONE REPL [3/3]
   - [X] Simple non-readline REPL
   - [X] Read in an initial file for REPL
   - [X] Readline support
** TODO Formatted output
   In addition to Arc standard prf, there will also be a printf
   function which can be used to output strings according to a format
   string specified.  The usual conversion specifiers for standard C
   printf are available, with some additional non-standard ones:
   - r or m : no argument required - print the output of
     strerror(errno).
   - v : replace by the pretty-printed form of the argument.

   This is also the same format specification used by the error
   handler function signal_error.

** TODO Dynamic Loader for external C functions
** TODO CIEL (src/ciel.c) [15/18]
   The CIEL dump/restore functionality allows Arcueid to save and load
   workspaces by tracing the global symbol table and threads and dumping
   those to a file.
   - [X] gnil
   - [X] gtrue
   - [X] gint
   - [X] gflo
   - [X] gchar
   - [X] gstr
   - [X] gsym
   - [X] gbstr - binary strings
   - [X] crat
   - [X] ccomplex
   - [X] ccons
   - [X] cannotate - this is for the moment limited to creating T_CODE
         objects from a cons consisting of the binary bytecode string
         and literals
   - [X] xdup
   - [X] xmst
   - [X] xmld
   - [ ] gtab
   - [ ] ctadd
   - [ ] additional functionality for cannotate, so that it can, you
	 know, actually perform type annotations...
* Enhancements
** TODO use ropes as strings
   This is a valuable enhancement as efficent string handling for very
   long strings will be very useful.
** TODO true OS-level threading
   The current interpreter is designed with green threads, scheduled
   by the virtual machine rather than native threads.
** TODO more advanced memory allocator
** TODO just in time compilation
** TODO PreArc?
   We do want to someday make a statically-typed, non-garbage
   collected dialect of Arc similar to Richard Kelsey's PreScheme, so
   we can write the entire runtime in Arc.
** TODO Format strings
   We will provide for format strings similar to C, but with a few
   extensions that make sense for Arc.
** TODO Character/string comparisons/translations
   Character/string comparisons, by default use the Unicode Collation
   algorithm (http://www.unicode.org/reports/tr10/)?  Capitalization
   and decapitalization should also be locale-defined. An
   implementation of the algorithms for doing these things appears to
   be ICU4C (http://site.icu-project.org).  See if we can adapt the
   code or use it as a library.
* Limitations that should be lifted
** Macro expansion
   - Macros cannot use threading primitives. Attempting to do so with
     the current version of arc_macapply will cause an immediate
     deadlock because macros are executed single threaded as the only
     thread available.
   - Garbage collection not performed during macro execution.  This
     requires some fairly careful work to ensure that local variables
     inside the compiler do not get garbage collected.
   - Macros can be anything but a CC4 function.  CC4 functions make some
     subtle interplay between the virtual machine and all that and can
     be somewhat difficult to handle.
** Compilation
   - We need to do tail call optimization somehow!
   - We need to do something about the kludge involved in reversing
     arguments for evaluation order.  Compiling a function application
     will push the arguments in the order in which they appear (so
     they appear on the stack in reverse order), but the compiler
     generates code to bind arguments on the stack as if they were
     pushed in the opposite order!  In order to fix this we have
     modified the virtual machine to reverse the order of all
     arguments in arc_apply. This is a really ugly kludge and should
     be cleaned up.
** Complex Rationals
   Apparently Arc has a complex rational numeric type:
   e.g. (sqrt -1/4) => 0+1/2i.
   At present Arcueid has no plans to support such creatures, and
   (sqrt -1/4) will produce 0+0.5i instead.  I suppose this is an
   artifact of numeric tower support in MzScheme/Racket, given the
   paucity of functions to otherwise support complex numbers in Arc.
